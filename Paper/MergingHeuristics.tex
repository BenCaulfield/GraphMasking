\section{Merging Heuristics}
\indent Unfortunately, although the label-swapping algorithm yields perfectly satisfying graphs, it often doesn't sufficiently disguise a given graph.  In this section, we present a heuristic, called \emph{adjacency group merges} (or simply \emph{merges}) that further randomizes a given graph, but is not guaranteed to maintain the same k-neighborhood. There are two versions of this heuristic that we developed, \emph{deterministic merges} and \emph{non-deterministic merges}.

\begin{definition}
\noindent A \emph{merge} or \emph{merging} of a graph's adjacency groups combines similar adjacency groups into larger groups containing the union of their nodes based on their \emph{difference}.
\end{definition}

\begin{definition}
The difference between adjacency groups $A$ and $B$ is the size of the symmetric difference of $N_k(v)$ and $N_k(u)$, for $v \in A$ and $u \in B$. 
\end{definition}

\subsection{Deterministic Merging}

\begin{definition}
A \emph{deterministic adjacency group merge} maps every pair of nodes to  the differencence value between their adjacency groups and merges adjacency groups of the first n that have not been involved in a previous merge.
\end{definition}

\begin{figure}[htb]
	\begin{algorithmic}
		\renewcommand{\algorithmicrequire}{\textbf{Input:}}
		\renewcommand{\algorithmicensure}{\textbf{Output:}}
		\Require {graph $G=(V,E)$, k-neighborhoods $K= \{k_{1}, k_{2}, ...\}$, adjecency groups $A=\{a_{1}, a_{2}, ...\}$, limit L}
		\Ensure {adjecency groups $A'$}
		\ForAll {$v \in V$}
			\ForAll {$w \in W$ where $v \neq w$}
				\State {find $Diff(A(v),A(w))$}
			\EndFor
		\EndFor
		\ForAll {$(v,w,d) \in V \times V \times {\mathbb Z}$ sorted by $d = Diff(A(v),A(w))$ where $v \neq w$}
			\State {$n = 0$}
		\EndFor
		\If {$not_merged(A(v))$ and $not_merged(A(w))$}
			\State {$merge(A(v),A(w))$}
			\State {$mark_as_merged(A(v))$}
			\State {$mark_as_merged(A(w))$}
			\State {$n++$}
			\If {$n == L$}
				\State {break}
			\EndIf
		\EndIf
	\end{algorithmic}
	\caption{Pseudocode for the Deterministic Merging Heuristic Algorithm.}
	\label{fig:deterministic-merging}
\end{figure}

\subsection{Non-Deterministic Merging}

\begin{definition}
A \emph{non-deterministic adjacency group merge} merges all of the pairs of randomly selected adjacency groups that have not been involved in a previous merge and have a \emph{difference} value less than or equal to a prescribed cutoff value.
\end{definition}

\begin{figure}[htb]
	\begin{algorithmic}
		\renewcommand{\algorithmicrequire}{\textbf{Input:}}
		\renewcommand{\algorithmicensure}{\textbf{Output:}}
		\Require {Integer $max_diff$, Graph $G = (V, E)$, Adjacency Groups $A$}
		\State {$current_diff = 0$}
		\State {$total_changes = 0$}
		\ForAll {$u \in V$}
			\If {$u$ has been altered}
				\State {continue}
			\EndIf
			\State {Integer $min_diff = max_diff + 1$}
			\State {Integer $min_pos = -1$}
			\State {Integer $min_diff2 = max_diff + 1$}
			\State {Integer $min_pos2 = -1$}
			\ForAll {$v \in V$}
				\If {$v < u$ or $v$ has been altered}
					\State {continue}
				\EndIf
				\If {$diff(u,v) < min_diff$ and $diff(u,v) \neq 0$ and $u$ does not share an adjacency group with $v$}
					\State {$min_diff = diff(u,v)$}
					\State {$min_pos = v$}
				\EndIf
			\EndFor
			\If {$min_pos \neq -1$}
				\State {$total_changes++$}
				\State {mark $u$ as altered}
				\State {mark $min_pos$ as altered}
				\State {$current_diff += min_diff$}
				\State {merge the two adjacency groups belinging to $u$ and $min_pos$}
			\EndIf
		\EndFor		
	\end{algorithmic}
	\caption{Pseudocode for the Non-Deterministic Merging Heuristic Algorithm.}
	\label{fig:non-deterministic-merging}
\end{figure}

